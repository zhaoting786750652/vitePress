import{_ as e,o as a,c as r,R as s}from"./chunks/framework.912ee41a.js";const h=JSON.parse('{"title":"webpack相关","description":"","frontmatter":{},"headers":[],"relativePath":"page/webpack.md","filePath":"page/webpack.md","lastUpdated":1685694891000}'),p={name:"page/webpack.md"},t=s('<h1 id="webpack相关" tabindex="-1">webpack相关 <a class="header-anchor" href="#webpack相关" aria-label="Permalink to &quot;webpack相关&quot;">​</a></h1><h2 id="transpiledependencies-true" tabindex="-1">transpileDependencies: true <a class="header-anchor" href="#transpiledependencies-true" aria-label="Permalink to &quot;transpileDependencies: true&quot;">​</a></h2><p>如果transpileDependencies为true或为正则，接着再看package.json里的browserslist是否处在低级浏览器范围，如果处在低级浏览器范围内，那么会把node_modules里用得到的高级语法进行babel编译。如果transpileDependencies为false,则会把node_modules里用到的高级语法原封不动的打包，会造成在低级浏览器访问报错的情况</p><h2 id="webpack热更新原理" tabindex="-1">webpack热更新原理 <a class="header-anchor" href="#webpack热更新原理" aria-label="Permalink to &quot;webpack热更新原理&quot;">​</a></h2><p>Hot Module Replacement应该所有人都知道，现象就是你修改代码保存之后，浏览器不会刷新，只会修改你更改过的依赖代码。我们平时用webpack-dev-server如果没有配置，是直接刷新浏览器，并不是热更新。 之前遇见几次问webpack热更新原理，我只是知道和怎么使用，也没真的去了解一下，这次了解了一下，发现没有对webpack深层次研究，根本不懂，所以今天只是简单了解一下，具体还是得去研究源码才能真正掌握。 实现webpack热更新就不说了，官网HMR指南写的很清楚，用vue开发或者用react开发也都可以看效果。至于HMR的好处说来说去就一个，提升开发效率，即不用你手动刷新浏览器，还可以保持浏览器状态。 我们一般用webpack-dev-server启动一个开发服务devServer，webpack内部实现watch，文件发生修改就重新打包编译保存在内存中，webpack-dev-server依赖中间件webpack-dev-middleware和webpack之间进行交互，如果文件变化了，没有配置热更新，webpack-dev-server会通知浏览器进行刷新，注意是刷新不是热更新。启动开发服务之后，浏览器和服务端是通过websocket进行长连接的，服务端主要是传递hash值，热更新主要是通过hash值判断进行热更新</p><h2 id="主要内容" tabindex="-1">主要内容 <a class="header-anchor" href="#主要内容" aria-label="Permalink to &quot;主要内容&quot;">​</a></h2><ul><li>entry，output，resolve配置</li><li>webpack如何寻找模块对应的文件(alias 路径别名)，</li><li>loaders (js ,jsx: babel-loader, less: css-loader , 图片，字体文件 :url-loader),</li><li>plugin如下：LoaderOptionsPlugin：pxtorem，sourceMap，eslint,vConsolePlugin</li></ul><h2 id="常用webpack插件" tabindex="-1">常用webpack插件 <a class="header-anchor" href="#常用webpack插件" aria-label="Permalink to &quot;常用webpack插件&quot;">​</a></h2><p>new CopyWebpackPlugin. ---复制 文件</p><p>new HtmlWebpackPlugin ---- 自动注入html</p><p>new webpack.DefinePlugin ---- 创建一个在编译时可以配置的全局常量（p<wbr>rocess.env.NODE_ENV ，，，node中，有全局变量process表示的是当前的node进程。p<wbr>rocess.env包含着关于系统环境的信息，NODE_ENV是用户一个自定义的变量，在webpack中它的用途是判断生产环境或开发环境的依据的，</p><p>loader的解析顺序是从下到上,从右往左,编译顺序应该是先用css-loader编译css代码,再用style-loader放入到网页的style标签里面去。所以css-loader在右,style-loader在左,按照指定顺序排列</p>',12),l=[t];function c(o,n,i,d,b,k){return a(),r("div",null,l)}const u=e(p,[["render",c]]);export{h as __pageData,u as default};
